# Битоническая сортировка на C с многопоточностью

## Описание

Программа реализует битоническую сортировку массива целых чисел в многопоточном режиме. Поддерживаются два варианта реализации синхронизации: на стандартных примитивах (mutex и condition variables) и на атомарных операциях (атомики C11). Программа позволяет ограничить максимальное количество одновременно работающих потоков, демонстрировать количество потоков через стандартные средства ОС и проводить измерения производительности для отчёта.

## Сборка

В каталоге `lab2` выполните:

```bash
make
```

Это создаст два исполняемых файла:
- `bitonic-sync` — версия на примитивах синхронизации (mutex/cond).
- `bitonic-atomic` — версия на атомиках.

## Запуск

### Синтаксис командной строки

```
./bitonic-sync -n <size> -t <threads> [-c] [--seed N] [--pause S] [--print-threads]
./bitonic-atomic -n <size> -t <threads> [-c] [--seed N] [--pause S] [--print-threads]
```

Параметры:
- `-n <size>` — количество элементов массива (обязательно, будет дополнено до степени двойки).
- `-t <threads>` — количество рабочих потоков (обязательно, >=1; программа ограничит до min(threads, size)).
- `-c` — проверить корректность сортировки после выполнения.
- `--seed N` — начальное зерно для генератора случайных чисел (по умолчанию — текущее время).
- `--pause S` — пауза в S секунд после создания потоков, перед началом сортировки (для демонстрации).
- `--print-threads` — вывести количество потоков из `/proc/self/status` (строка "Threads:").
- `-h` или `--help` — показать справку.

### Примеры

- Запуск с проверкой: `./bitonic-sync -n 1024 -t 4 -c`
- С фиксированным seed: `./bitonic-sync -n 100000 -t 8 -c --seed 42`
- Демонстрация потоков: `./bitonic-sync -n 1024 -t 4 --print-threads --pause 5`

## Детали работы

### Алгоритм битонической сортировки

Битоническая сортировка — параллельный алгоритм сортировки, работающий за O(log² n) этапов. Каждый этап состоит из подэтапов, где элементы сравниваются и обмениваются в парах. Массив должен быть размера степени двойки; если нет, он дополняется до ближайшей степени двойки значениями INT_MAX.

Основной цикл:
- Для k от 2 до np2 (np2 — размер массива, степень двойки) с удвоением:
  - Для j от k/2 до 1 с делением на 2:
    - Для каждого i в диапазоне потока:
      - Вычислить пару l = i ^ j
      - Если l > i, выполнить compare_swap с направлением ascend = ((i & k) == 0)

### Многопоточность

- **Рабочие потоки**: Создаются nthreads потоков, каждый обрабатывает непрерывный диапазон индексов массива (chunk = np2 / nthreads).
- **Синхронизация**: Между подэтапами (после каждого j) все потоки синхронизируются барьером, чтобы гарантировать корректность сравнений.
- **Ограничение потоков**: Максимум nthreads одновременно работающих потоков; программа ограничивает nthreads <= np2.

### Режимы синхронизации

#### MODE_SYNC (bitonic-sync)
- Барьер реализован на `pthread_mutex_t` и `pthread_cond_t`.
- Структура барьера: mutex, cond, count, trip, n.
- `barrier_wait`: блокирует mutex, инкрементирует count, если последний — будит всех, иначе ждёт cond.
- Дополнительный барьер start_barrier (nthreads + 1) для синхронного старта после паузы.

#### MODE_ATOMIC (bitonic-atomic)
- Барьер на атомиках: `atomic_int count`, `atomic_int sense`.
- `barrier_wait_local`: использует fetch_add для count, если последний — сбрасывает count и sense, иначе спин-ожидание с sched_yield.
- Старт через атомарный флаг `_Atomic bool start_flag`, потоки ждут его установки в true.

### Демонстрация количества потоков

- Опция `--print-threads`: читает `/proc/self/status` и выводит строку "Threads:".
- Во время паузы (`--pause S`) можно использовать внешние инструменты:
  - `ps -L -p <PID>` — показать LWP (lightweight processes, т.е. потоки).
  - `top -H -p <PID>` — top с потоками.
  - `cat /proc/<PID>/status` — полная информация, включая Threads.

### Измерения производительности

Для отчёта измерьте время выполнения при разных n и t, для обеих версий.

- **Базовое время**: T1 — время при t=1.
- **Ускорение**: S_p = T1 / T_p (p — число потоков).
- **Эффективность**: E_p = S_p / p.

Рекомендуемые тесты:
- n: 16, 100 (→128), 1024, 100000 (→131072), 1000000 (→1048576).
- t: 1, 2, 4, 8, ..., до числа ядер (узнайте через `nproc`).
- Повторы: 5–10 запусков на набор, усреднить.
- Фиксированный seed для воспроизводимости.

Пример скрипта для измерений (bash):

```bash
#!/bin/bash
for mode in sync atomic; do
    echo "Mode: $mode"
    for n in 1024 100000; do
        for t in 1 2 4; do
            echo -n "n=$n t=$t: "
            ./bitonic-$mode -n $n -t $t --seed 42 | grep Time
        done
    done
done
```

### Зависимости

- Компилятор: gcc с поддержкой C11 и pthreads.
- ОС: Linux (для /proc/self/status).
- Библиотеки: pthread, stdatomic (для atomic версии).

### Ограничения

- Размер массива: до ~10^7 элементов (зависит от памяти).
- Потоки: до 1024 (ограничение ОС).
- Данные: int32, случайные или фиксированные seed.

### Структура кода

- `bitonic.c`: основной файл.
- `Makefile`: сборка.
- Утилиты: now_ns (время), next_pow2 (округление), print_thread_count (печать потоков).
- Барьеры: barrier_t с init/destroy/wait.
- Контекст потока: worker_ctx_t.
- worker_fn: цикл сортировки с барьерами.
- main: парсинг CLI, инициализация, запуск, замер, проверка.</content>
<parameter name="filePath">/home/divan/vladeemer labs/lab2/README.md
